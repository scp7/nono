---
title: Usage Overview
description: Learn how to use nono to sandbox commands
---

nono wraps any command with an OS-level sandbox. You specify what the command is allowed to access, and nono enforces those restrictions at the kernel level.


## Commands

nono provides the following commands:

| Command | Description |
|---------|-------------|
| `nono run` | Run a command inside the sandbox |
| `nono shell` | Start an interactive shell inside the sandbox |
| `nono why` | Check why a path/network operation would be allowed or denied |
| `nono setup` | Set up profiles and verify installation |
| `nono undo` | Manage undo sessions (browse, restore, cleanup) |
| `nono audit` | View audit trail of sandboxed sessions |
| `nono learn` | Trace a command to discover required paths (Linux only) |

## Running Commands (`nono run`)

### Basic Syntax

```bash
nono run [OPTIONS] -- <COMMAND> [ARGS...]
```

<Note>
The `--` separator is recommended. Everything after it is the command to run.
</Note>
### Minimal Example

```bash
# Grant read+write access to current directory, run claude
nono run --allow . -- claude
```

## Checking Path Access (`nono why`)

The `why` command checks if a path or network operation would be allowed or denied. It's designed for both human debugging and programmatic use by AI agents.

```bash
nono why --path <PATH> --op <OP> [OPTIONS]
nono why --host <HOST> [--port <PORT>] [OPTIONS]
nono why --self --path <PATH> --op <OP> [OPTIONS]  # Inside sandbox
```

### Examples

```bash
# Check if a sensitive path would be blocked
nono why --path ~/.ssh/id_rsa --op read
# Output: DENIED - sensitive_path (SSH keys and config)

# Check with capability context
nono why --path ./src --op write --allow .
# Output: ALLOWED - Granted by: --allow .

# JSON output for AI agents
nono why --json --path ~/.aws --op read
# {"status":"denied","reason":"sensitive_path","category":"AWS credentials",...}

# From inside a sandbox, query own capabilities
nono run --allow . -- nono why --self --path /tmp --op write --json
```

### Options

| Flag | Description |
|------|-------------|
| `--path` | Filesystem path to check |
| `--op` | Operation: `read`, `write`, or `readwrite` (default: `read`) |
| `--host` | Network host to check (instead of `--path`) |
| `--port` | Network port (default: 443) |
| `--json` | Output JSON for programmatic use |
| `--self` | Query current sandbox state (inside sandbox) |

## Interactive Shell (`nono shell`)

Start a shell with the same sandbox and permissions as `nono run`, but without wrapping each command.

```bash
nono shell [OPTIONS]
```

```bash
# Shell with access only to current directory
nono shell --allow .

# Shell with a named profile
nono shell --profile claude-code

# Override the shell binary
nono shell --allow . --shell /bin/zsh
```

Exit the shell with `Ctrl-D` or `exit`.

## Supervised Mode and Undo

Supervised mode (`--supervised`) enables the undo system, which takes filesystem snapshots before and after execution. If an agent makes unwanted changes, you can restore files to their previous state.

```bash
# Run with undo enabled
nono run --supervised --allow . -- claude

# After exit, you'll be prompted to review changes and optionally restore
```

When the sandboxed process exits, nono presents an interactive prompt showing what files changed. You can restore to the pre-session state or exit without changes.

### Managing Undo Sessions

Use `nono undo` to manage past sessions:

```bash
# List sessions with file changes
nono undo list

# Show changes in a session
nono undo show 20260214-143022-12345 --diff

# Restore files from a session (dry-run first)
nono undo restore 20260214-143022-12345 --dry-run

# Verify session integrity
nono undo verify 20260214-143022-12345

# Clean up old sessions
nono undo cleanup --older-than 30
```

### Audit Trail

Use `nono audit` to review the audit trail of all sandboxed sessions:

```bash
# List all sessions
nono audit list

# Filter by date or command
nono audit list --today --command claude

# Show audit details for a session
nono audit show 20260214-143022-12345 --json
```

## Understanding Permissions

nono provides three levels of filesystem access:

| Flag | Access Level | Use Case |
|------|--------------|----------|
| `--allow` / `-a` | Read + Write | Working directories, project folders |
| `--read` / `-r` | Read Only | Source code, configuration |
| `--write` / `-w` | Write Only | Output directories, logs |

### Directory vs File Permissions

- **Directory flags** (`--allow`, `--read`, `--write`) grant recursive access
- **File flags** (`--allow-file`, `--read-file`, `--write-file`) grant access to a single file

```bash
# Recursive access to entire directory
nono run --allow ./project -- command

# Access to single config file only
nono run --read-file ./config.toml -- command
```

## Network Access

Network is **allowed by default**. Use `--net-block` to disable outbound connections:

```bash
# Block network access for offline build
nono run --allow . --net-block -- cargo build
```

<Note>
  Network access is currently all-or-nothing. You can either allow all network access (default) or block it entirely with `--net-block`.

  Granular filtering (allowing only specific domains) is not yet supported due to technical limitations in Apple Seatbelt and requires experimentation. This feature may be added in a future release.
</Note>

## What Happens at Runtime

1. **Parse** - nono parses your capability flags
2. **Canonicalize** - All paths are resolved to absolute paths (prevents symlink escapes)
3. **Apply Sandbox** - Kernel sandbox is initialized (irreversible)
4. **Execute** - nono exec()s into your command, inheriting the sandbox
5. **Enforce** - Kernel blocks any unauthorized access attempts

## Querying Sandbox Capabilities

When running inside a nono sandbox, processes can query their own capabilities using `nono why --self`:

```bash
# Check if a path is accessible
nono why --self --path /tmp --op write --json
# {"status":"denied","reason":"not_in_allowed_paths","suggestion":"--write /tmp"}

# Check network access
nono why --self --host api.openai.com
# ALLOWED - network allowed by default
```

This is particularly useful for AI agents - when an operation fails, the agent can call `nono why --self` to get a structured JSON response explaining why and how to fix it.

<Note>
The only environment variable nono sets is `NONO_CAP_FILE`, which points to the capability state file. Use `nono why --self` instead of parsing environment variables directly.
</Note>

## Secrets Management

nono can securely load API keys from the system keystore (macOS Keychain / Linux Secret Service) and inject them as environment variables:

```bash
# Store a secret in the keystore
security add-generic-password -s "nono" -a "openai_api_key" -w "sk-..."

# Use the secret in a sandboxed command
nono run --allow . --secrets openai_api_key -- my-agent
```

Secrets are loaded **before** the sandbox is applied, so the sandboxed process cannot access the keystore directly - only the specific secrets you authorize.

See [Secrets Management](/usage/secrets) for full documentation.

## Sensitive Paths

The following paths are always blocked by default to protect credentials:

- `~/.ssh` - SSH keys
- `~/.aws`, `~/.gcloud`, `~/.azure` - Cloud credentials
- `~/.gnupg` - GPG keys
- `~/.kube`, `~/.docker` - Container credentials
- `~/.zshrc`, `~/.bashrc`, `~/.profile` - Shell configs (often contain secrets)
- `~/.npmrc`, `~/.git-credentials` - Package manager tokens

Use `nono why --path <path> --op read` to check if a specific path is blocked and why.

## Next Steps

- [CLI Reference](/usage/flags) - Complete flag documentation
- [Secrets Management](/usage/secrets) - Secure API key loading from system keystore
- [Examples](/usage/examples) - Common usage patterns
