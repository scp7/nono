---
title: Cryptographic Signing
description: How nono uses signatures to ensure configuration integrity
---

nono uses [minisign](https://jedisct1.github.io/minisign/) signatures to verify the integrity and authenticity of security-critical configuration files. This prevents tampering with security lists and profiles.

## Why Signing?

Security lists define which paths are sensitive and which commands are dangerous. If an attacker could modify these lists, they could:

- Remove `~/.ssh` from sensitive paths, enabling key theft
- Remove `rm` from dangerous commands, enabling destructive operations
- Add exceptions that weaken security

Cryptographic signatures ensure that configuration files haven't been tampered with since they were created by a trusted author.

## Trust Hierarchy

nono uses a three-tier trust model:

| Level | Source | Signature | Trust |
|-------|--------|-----------|-------|
| 1 | Embedded (binary) | Author key | Highest - compiled in |
| 2 | System (`/etc/nono/`) | Admin key | High - org-managed |
| 3 | User (`~/.config/nono/`) | Optional | Medium - user responsibility |

### Author Key (Built-in)

The nono binary contains an embedded public key used to verify the built-in security lists. This key is controlled by the nono maintainers and is the root of trust.

### Admin Keys (Enterprise)

Organizations can deploy additional security rules in `/etc/nono/` signed with their own keys. These extend (but cannot weaken) the built-in rules.

### User Signatures (Optional)

Users can optionally sign their own profiles for integrity verification. This is useful for detecting accidental corruption or unauthorized modifications.

## Signing Your Own Profiles

### Install minisign

```bash
# macOS
brew install minisign

# Linux (Debian/Ubuntu)
apt install minisign

# From source
cargo install minisign
```

### Generate a Signing Key

```bash
# Generate a new keypair
minisign -G -p my-key.pub -s my-key.key

# You'll be prompted for a password to protect the secret key
```

This creates two files:
- `my-key.pub` - Public key (share this)
- `my-key.key` - Secret key (keep this secure!)

### Sign a Profile

```bash
# Sign a profile file
minisign -Sm ~/.config/nono/profiles/my-agent.toml -s my-key.key

# This creates my-agent.toml.minisig
```

### Verify a Signature

```bash
# Verify manually
minisign -Vm my-agent.toml -p my-key.pub

# nono verifies automatically when .minisig file is present
```

## Adding Trusted Keys

To trust signatures from third parties (e.g., your organization's security team):

### 1. Create the trusted keys directory

```bash
mkdir -p ~/.config/nono/trusted-keys
```

### 2. Add the public key

```bash
# Copy the public key file
cp org-security.pub ~/.config/nono/trusted-keys/

# Or create from the key string
echo "RWTk1xXq..." > ~/.config/nono/trusted-keys/org-security.pub
```

### 3. Register in config (optional metadata)

```toml
# ~/.config/nono/config.toml
[trusted_keys]
org-security = { name = "Org Security Team", fingerprint = "abc123" }
```

## Signature Format

nono uses minisign's standard signature format. A `.minisig` file looks like:

```
untrusted comment: signature from minisign secret key
RWTk1xXqcTO...base64-encoded-signature...
trusted comment: timestamp:1234567890 file:security-lists.toml
...base64-encoded-global-signature...
```

The trusted comment includes:
- `timestamp` - When the file was signed
- `file` - Original filename
- Optional: `version` - Config version for downgrade protection

## Downgrade Protection

nono tracks the version of security lists it has seen. If someone tries to replace current lists with an older (but still validly signed) version, nono rejects it.

Version state is stored in:
- macOS: `~/Library/Application Support/nono/versions.json`
- Linux: `~/.local/state/nono/versions.json`

Example version state:

```json
{
  "security-lists": {
    "version": 5,
    "last_seen": "2025-01-15T10:30:00Z",
    "source": "embedded"
  }
}
```

## Unsigned Development Builds

During development, nono can run without signatures. The build system detects whether signature files are present:

- **With signatures**: Full verification enabled
- **Without signatures**: Debug warning logged, verification skipped

Official releases always include signatures. If you're building from source and see "unsigned" warnings, this is expected for development builds.

## Security Considerations

### Protect Your Secret Key

- Never commit secret keys to version control (GitHub, etc.)
- Use a strong password when generating keys
- Consider storing keys in a hardware security module (HSM) for production

### Key Rotation

If you need to rotate keys:

1. Generate a new keypair
2. Sign a transition document with both old and new keys
3. Distribute the new public key
4. Re-sign all configuration files with the new key

### Revocation

Minisign doesn't have built-in revocation. If a key is compromised:

1. Remove the public key from all `trusted-keys` directories
2. Bump the version number in your security lists
3. Re-sign with a new key
4. Distribute the update (the version bump prevents rollback)

## Verifying Official Releases

Official nono releases are signed with the project's release key. To verify:

```bash
# Download the release and signature
curl -LO https://github.com/lukehinds/nono/releases/download/v0.2.0/nono-v0.2.0-darwin-arm64.tar.gz
curl -LO https://github.com/lukehinds/nono/releases/download/v0.2.0/nono-v0.2.0-darwin-arm64.tar.gz.minisig

# Verify with the project public key
minisign -Vm nono-v0.2.0-darwin-arm64.tar.gz -P "RWTk1xXqcTODeYttYMCqEwcLg..."
```

The project public key is published at:
- GitHub releases page
- Project README
- https://nono.dev/security/signing (this page)
- Rekor transparency log

## Next Steps

- [Security Model](index.mdx) - Understanding nono's security guarantees
- [Profiles](../profiles/index.mdx) - Creating and using profiles
