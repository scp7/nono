/* nono C FFI - Capability-based sandboxing */
/* Generated by cbindgen - DO NOT EDIT */

#ifndef NONO_H
#define NONO_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Access mode for filesystem capabilities.
 *
 * Constants: `NONO_ACCESS_MODE_READ` (0), `NONO_ACCESS_MODE_WRITE` (1),
 * `NONO_ACCESS_MODE_READ_WRITE` (2).
 *
 * Represented as `u32` at the FFI boundary to prevent undefined behavior
 * from invalid enum discriminants. Validated on entry to each FFI function.
 */
#define NONO_ACCESS_MODE_READ 0

#define NONO_ACCESS_MODE_WRITE 1

#define NONO_ACCESS_MODE_READ_WRITE 2

/**
 * Tag for capability source discriminant.
 */
typedef enum NonoCapabilitySourceTag {
    /**
     * Added directly by the user via CLI flags
     */
    NONO_CAPABILITY_SOURCE_TAG_USER = 0,
    /**
     * Resolved from a named policy group
     */
    NONO_CAPABILITY_SOURCE_TAG_GROUP = 1,
    /**
     * System-level path
     */
    NONO_CAPABILITY_SOURCE_TAG_SYSTEM = 2,
    /**
     * Added from a profile's filesystem section
     */
    NONO_CAPABILITY_SOURCE_TAG_PROFILE = 3,
} NonoCapabilitySourceTag;

/**
 * Error codes returned by nono FFI functions.
 *
 * Zero means success. Negative values indicate error categories.
 * Call `nono_last_error()` for the detailed error message.
 */
typedef enum NonoErrorCode {
    /**
     * Operation succeeded.
     */
    NONO_ERROR_CODE_OK = 0,
    /**
     * Path does not exist.
     */
    NONO_ERROR_CODE_ERR_PATH_NOT_FOUND = -1,
    /**
     * Expected a directory but got a file.
     */
    NONO_ERROR_CODE_ERR_EXPECTED_DIRECTORY = -2,
    /**
     * Expected a file but got a directory.
     */
    NONO_ERROR_CODE_ERR_EXPECTED_FILE = -3,
    /**
     * Path canonicalization failed.
     */
    NONO_ERROR_CODE_ERR_PATH_CANONICALIZATION = -4,
    /**
     * No capabilities specified.
     */
    NONO_ERROR_CODE_ERR_NO_CAPABILITIES = -5,
    /**
     * Sandbox initialization failed.
     */
    NONO_ERROR_CODE_ERR_SANDBOX_INIT = -6,
    /**
     * Platform not supported.
     */
    NONO_ERROR_CODE_ERR_UNSUPPORTED_PLATFORM = -7,
    /**
     * Command is blocked.
     */
    NONO_ERROR_CODE_ERR_BLOCKED_COMMAND = -8,
    /**
     * Configuration parse error.
     */
    NONO_ERROR_CODE_ERR_CONFIG_PARSE = -9,
    /**
     * Profile parse error.
     */
    NONO_ERROR_CODE_ERR_PROFILE_PARSE = -10,
    /**
     * I/O error.
     */
    NONO_ERROR_CODE_ERR_IO = -11,
    /**
     * Invalid argument (NULL pointer, invalid UTF-8).
     */
    NONO_ERROR_CODE_ERR_INVALID_ARG = -12,
    /**
     * Unknown or uncategorized error.
     */
    NONO_ERROR_CODE_ERR_UNKNOWN = -99,
} NonoErrorCode;

/**
 * Reason code for a query result.
 */
typedef enum NonoQueryReason {
    /**
     * Path is covered by a granted capability
     */
    NONO_QUERY_REASON_GRANTED_PATH = 0,
    /**
     * Network access is not blocked
     */
    NONO_QUERY_REASON_NETWORK_ALLOWED = 1,
    /**
     * Path not covered by any capability
     */
    NONO_QUERY_REASON_PATH_NOT_GRANTED = 2,
    /**
     * Path covered but with insufficient access level
     */
    NONO_QUERY_REASON_INSUFFICIENT_ACCESS = 3,
    /**
     * Network access is blocked
     */
    NONO_QUERY_REASON_NETWORK_BLOCKED = 4,
} NonoQueryReason;

/**
 * Status of a query result.
 */
typedef enum NonoQueryStatus {
    NONO_QUERY_STATUS_ALLOWED = 0,
    NONO_QUERY_STATUS_DENIED = 1,
} NonoQueryStatus;

/**
 * Result of a permission query.
 *
 * String fields are nullable. Non-NULL string fields are caller-owned
 * and must be freed with `nono_string_free()`.
 */
typedef struct NonoQueryResult {
    /**
     * Whether the operation is allowed or denied.
     */
    enum NonoQueryStatus status;
    /**
     * The specific reason.
     */
    enum NonoQueryReason reason;
    /**
     * For `GrantedPath`: the path that grants access. NULL otherwise.
     */
    char *granted_path;
    /**
     * For `GrantedPath`: the access mode string. NULL otherwise.
     */
    char *access;
    /**
     * For `InsufficientAccess`: the granted access mode. NULL otherwise.
     */
    char *granted;
    /**
     * For `InsufficientAccess`: the requested access mode. NULL otherwise.
     */
    char *requested;
} NonoQueryResult;

/**
 * Platform support information.
 *
 * Returned by `nono_sandbox_support_info()`.
 * Caller must free string fields with `nono_string_free()`.
 */
typedef struct NonoSupportInfo {
    /**
     * Whether sandboxing is supported on this platform.
     */
    bool is_supported;
    /**
     * Platform name. Caller must free with `nono_string_free()`.
     */
    char *platform;
    /**
     * Detailed support information. Caller must free with `nono_string_free()`.
     */
    char *details;
} NonoSupportInfo;

/**
 * Get the last error message for the current thread.
 *
 * Returns a caller-owned copy of the last error message as a
 * null-terminated UTF-8 string, or NULL if no error has occurred.
 *
 * Caller must free the returned string with `nono_string_free()`.
 */
char *nono_last_error(void);

/**
 * Clear the last error for the current thread.
 */
void nono_clear_error(void);

/**
 * Free a string previously returned by a nono FFI function.
 *
 * NULL-safe (no-op on NULL). Call this on any string whose documentation
 * says "Caller must free with `nono_string_free()`", including
 * `nono_last_error()` and `nono_version()`.
 *
 * # Safety
 *
 * `s` must be NULL or a pointer previously returned by a nono FFI function.
 */
void nono_string_free(char *s);

/**
 * Get the nono library version string.
 *
 * Caller must free the returned string with `nono_string_free()`.
 */
char *nono_version(void);

/**
 * Create a new empty capability set.
 *
 * The returned pointer is never NULL. Caller must free with
 * `nono_capability_set_free()`.
 */
struct NonoCapabilitySet *nono_capability_set_new(void);

/**
 * Free a capability set.
 *
 * NULL-safe (no-op on NULL).
 *
 * # Safety
 *
 * `caps` must be NULL or a pointer previously returned by
 * `nono_capability_set_new()` or a factory function.
 */
void nono_capability_set_free(struct NonoCapabilitySet *caps);

/**
 * Add directory access permission.
 *
 * The path is validated and canonicalized. Returns `Ok` on success.
 * On failure, returns a negative error code; call `nono_last_error()`
 * for the detailed message.
 *
 * # Safety
 *
 * - `caps` must be a valid pointer from `nono_capability_set_new()`.
 * - `path` must be a valid null-terminated UTF-8 string.
 */
enum NonoErrorCode nono_capability_set_allow_path(struct NonoCapabilitySet *caps,
                                                  const char *path,
                                                  uint32_t mode);

/**
 * Add single-file access permission.
 *
 * The path is validated and canonicalized. Returns `Ok` on success.
 *
 * # Safety
 *
 * - `caps` must be a valid pointer from `nono_capability_set_new()`.
 * - `path` must be a valid null-terminated UTF-8 string.
 */
enum NonoErrorCode nono_capability_set_allow_file(struct NonoCapabilitySet *caps,
                                                  const char *path,
                                                  uint32_t mode);

/**
 * Set whether outbound network access is blocked.
 *
 * Returns `Ok` on success, or `ErrInvalidArg` if `caps` is NULL.
 *
 * # Safety
 *
 * `caps` must be a valid pointer from `nono_capability_set_new()`.
 */
enum NonoErrorCode nono_capability_set_set_network_blocked(struct NonoCapabilitySet *caps,
                                                           bool blocked);

/**
 * Add a command to the allow list (overrides block lists).
 *
 * # Safety
 *
 * - `caps` must be a valid pointer.
 * - `cmd` must be a valid null-terminated UTF-8 string.
 */
enum NonoErrorCode nono_capability_set_allow_command(struct NonoCapabilitySet *caps,
                                                     const char *cmd);

/**
 * Add a command to the block list.
 *
 * # Safety
 *
 * - `caps` must be a valid pointer.
 * - `cmd` must be a valid null-terminated UTF-8 string.
 */
enum NonoErrorCode nono_capability_set_block_command(struct NonoCapabilitySet *caps,
                                                     const char *cmd);

/**
 * Add a raw platform-specific sandbox rule.
 *
 * On macOS this is a Seatbelt S-expression. On Linux it is ignored.
 * Returns `Ok` on success or a negative error code if the rule is
 * malformed or grants root-level access.
 *
 * # Safety
 *
 * - `caps` must be a valid pointer.
 * - `rule` must be a valid null-terminated UTF-8 string.
 */
enum NonoErrorCode nono_capability_set_add_platform_rule(struct NonoCapabilitySet *caps,
                                                         const char *rule);

/**
 * Deduplicate filesystem capabilities, keeping the highest access level.
 *
 * # Safety
 *
 * `caps` must be a valid pointer.
 */
void nono_capability_set_deduplicate(struct NonoCapabilitySet *caps);

/**
 * Check if a path is covered by an existing directory capability.
 *
 * Returns `false` if `caps` or `path` is NULL.
 *
 * # Safety
 *
 * - `caps` must be a valid pointer or NULL.
 * - `path` must be a valid null-terminated UTF-8 string or NULL.
 */
bool nono_capability_set_path_covered(const struct NonoCapabilitySet *caps, const char *path);

/**
 * Check if outbound network access is blocked.
 *
 * Returns `false` if `caps` is NULL.
 *
 * # Safety
 *
 * `caps` must be a valid pointer or NULL.
 */
bool nono_capability_set_is_network_blocked(const struct NonoCapabilitySet *caps);

/**
 * Get a plain-text summary of the capability set.
 *
 * Caller must free the returned string with `nono_string_free()`.
 * Returns NULL if `caps` is NULL.
 *
 * # Safety
 *
 * `caps` must be a valid pointer or NULL.
 */
char *nono_capability_set_summary(const struct NonoCapabilitySet *caps);

/**
 * Get the number of filesystem capabilities in the set.
 *
 * Returns 0 if `caps` is NULL.
 *
 * # Safety
 *
 * `caps` must be a valid pointer or NULL.
 */
uintptr_t nono_capability_set_fs_count(const struct NonoCapabilitySet *caps);

/**
 * Get the original (pre-canonicalization) path of the capability at `index`.
 *
 * Caller must free the returned string with `nono_string_free()`.
 * Returns NULL if `caps` is NULL or `index` is out of bounds.
 *
 * # Safety
 *
 * `caps` must be a valid pointer or NULL.
 */
char *nono_capability_set_fs_original(const struct NonoCapabilitySet *caps, uintptr_t index);

/**
 * Get the resolved (canonicalized) path of the capability at `index`.
 *
 * Caller must free the returned string with `nono_string_free()`.
 * Returns NULL if `caps` is NULL or `index` is out of bounds.
 *
 * # Safety
 *
 * `caps` must be a valid pointer or NULL.
 */
char *nono_capability_set_fs_resolved(const struct NonoCapabilitySet *caps, uintptr_t index);

/**
 * Get the access mode of the capability at `index`.
 *
 * Returns `NONO_ACCESS_MODE_READ` (0) as default if `caps` is NULL or
 * `index` is out of bounds. Check `nono_capability_set_fs_count()` first.
 *
 * # Safety
 *
 * `caps` must be a valid pointer or NULL.
 */
uint32_t nono_capability_set_fs_access(const struct NonoCapabilitySet *caps, uintptr_t index);

/**
 * Get whether the capability at `index` is a single-file capability.
 *
 * Returns `false` if `caps` is NULL or `index` is out of bounds.
 *
 * # Safety
 *
 * `caps` must be a valid pointer or NULL.
 */
bool nono_capability_set_fs_is_file(const struct NonoCapabilitySet *caps, uintptr_t index);

/**
 * Get the source tag of the capability at `index`.
 *
 * Returns `NonoCapabilitySourceTag::User` as default if `caps` is NULL
 * or `index` is out of bounds.
 *
 * # Safety
 *
 * `caps` must be a valid pointer or NULL.
 */
enum NonoCapabilitySourceTag nono_capability_set_fs_source_tag(const struct NonoCapabilitySet *caps,
                                                               uintptr_t index);

/**
 * Get the group name of the capability at `index`.
 *
 * Returns NULL if the source is not `Group`, or if `caps` is NULL,
 * or if `index` is out of bounds.
 *
 * Caller must free the returned string with `nono_string_free()`.
 *
 * # Safety
 *
 * `caps` must be a valid pointer or NULL.
 */
char *nono_capability_set_fs_source_group_name(const struct NonoCapabilitySet *caps,
                                               uintptr_t index);

/**
 * Create a query context from a capability set.
 *
 * The capability set is cloned internally. The returned pointer is never
 * NULL. Caller must free with `nono_query_context_free()`.
 *
 * # Safety
 *
 * `caps` must be a valid pointer from `nono_capability_set_new()`.
 * Returns NULL if `caps` is NULL.
 */
struct NonoQueryContext *nono_query_context_new(const struct NonoCapabilitySet *caps);

/**
 * Free a query context.
 *
 * NULL-safe (no-op on NULL).
 *
 * # Safety
 *
 * `ctx` must be NULL or a pointer previously returned by
 * `nono_query_context_new()`.
 */
void nono_query_context_free(struct NonoQueryContext *ctx);

/**
 * Query whether a path operation is permitted.
 *
 * Writes the result to `out_result`. Returns `Ok` on success.
 *
 * Caller must free non-NULL string fields in `out_result` with
 * `nono_string_free()`.
 *
 * # Safety
 *
 * - `ctx` must be a valid pointer from `nono_query_context_new()`.
 * - `path` must be a valid null-terminated UTF-8 string.
 * - `out_result` must be a valid writable pointer.
 */
enum NonoErrorCode nono_query_context_query_path(const struct NonoQueryContext *ctx,
                                                 const char *path,
                                                 uint32_t mode,
                                                 struct NonoQueryResult *out_result);

/**
 * Query whether network access is permitted.
 *
 * Writes the result to `out_result`. Returns `Ok` on success.
 *
 * # Safety
 *
 * - `ctx` must be a valid pointer from `nono_query_context_new()`.
 * - `out_result` must be a valid writable pointer.
 */
enum NonoErrorCode nono_query_context_query_network(const struct NonoQueryContext *ctx,
                                                    struct NonoQueryResult *out_result);

/**
 * Apply the sandbox with the given capabilities.
 *
 * This is **irreversible**. Once applied, the current process and all
 * children can only access resources granted by the capabilities.
 *
 * Returns `Ok` on success.
 *
 * # Safety
 *
 * `caps` must be a valid pointer from `nono_capability_set_new()`.
 */
enum NonoErrorCode nono_sandbox_apply(const struct NonoCapabilitySet *caps);

/**
 * Check if sandboxing is supported on this platform.
 */
bool nono_sandbox_is_supported(void);

/**
 * Get detailed platform support information.
 *
 * Caller must free `platform` and `details` fields with
 * `nono_string_free()`.
 */
struct NonoSupportInfo nono_sandbox_support_info(void);

/**
 * Create a state snapshot from a capability set.
 *
 * Returns NULL if `caps` is NULL.
 * Caller must free with `nono_sandbox_state_free()`.
 *
 * # Safety
 *
 * `caps` must be a valid pointer or NULL.
 */
struct NonoSandboxState *nono_sandbox_state_from_caps(const struct NonoCapabilitySet *caps);

/**
 * Free a sandbox state.
 *
 * NULL-safe (no-op on NULL).
 *
 * # Safety
 *
 * `state` must be NULL or a pointer previously returned by
 * `nono_sandbox_state_from_caps()` or `nono_sandbox_state_from_json()`.
 */
void nono_sandbox_state_free(struct NonoSandboxState *state);

/**
 * Serialize the state to a JSON string.
 *
 * Caller must free the returned string with `nono_string_free()`.
 * Returns NULL if `state` is NULL.
 *
 * # Safety
 *
 * `state` must be a valid pointer or NULL.
 */
char *nono_sandbox_state_to_json(const struct NonoSandboxState *state);

/**
 * Deserialize state from a JSON string.
 *
 * Returns NULL on parse error (call `nono_last_error()` for details).
 * Caller must free with `nono_sandbox_state_free()`.
 *
 * # Safety
 *
 * `json` must be a valid null-terminated UTF-8 string.
 */
struct NonoSandboxState *nono_sandbox_state_from_json(const char *json);

/**
 * Convert a state snapshot back to a capability set.
 *
 * Returns NULL on error (e.g. if referenced paths no longer exist).
 * Call `nono_last_error()` for the detailed message.
 * Caller must free with `nono_capability_set_free()`.
 *
 * # Safety
 *
 * `state` must be a valid pointer or NULL.
 */
struct NonoCapabilitySet *nono_sandbox_state_to_caps(const struct NonoSandboxState *state);

#endif  /* NONO_H */
